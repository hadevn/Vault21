#pragma once
#include "PIDManager.h"
#include <tlhelp32.h>
#include <tchar.h>


namespace HACKUZAN {

	/*
	DWORD_PTR PIDManager::GetModuleBase(DWORD dwPid, LPCTSTR szModName)
	{
		HANDLE        hSnap;
		MODULEENTRY32 me;
		me.dwSize = sizeof(me);
		hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPid);
		if (hSnap == INVALID_HANDLE_VALUE)
		{
			return 0;
		}
		BOOL bRet = Module32First(hSnap, &me);
		while (bRet)
		{
			if (_tcsicmp(me.szModule, szModName) == 0)
			{
				CloseHandle(hSnap);
				return DWORD_PTR(me.modBaseAddr);
			}
			bRet = Module32Next(hSnap, &me);
		}
		CloseHandle(hSnap);
	}
	int PIDManager::GetProcessIdByName(LPCTSTR szProcess)//ע��Ҫ��exe��׺
	{
		int dwRet = -1;
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		PROCESSENTRY32 pe32;
		pe32.dwSize = sizeof(PROCESSENTRY32);
		Process32First(hSnapshot, &pe32);
		do
		{
			if (_tcsicmp(pe32.szExeFile, szProcess) == 0)
			{
				dwRet = pe32.th32ProcessID;
				break;
			}
		} while (Process32Next(hSnapshot, &pe32));
		CloseHandle(hSnapshot);
		return dwRet;
	}
	BOOL PIDManager::EnableDebugPriv()
	{
		HANDLE   hToken;
		LUID   sedebugnameValue;
		TOKEN_PRIVILEGES   tkp;
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		{
			return   FALSE;
		}
		if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &sedebugnameValue))
		{
			CloseHandle(hToken);
			return   FALSE;
		}
		tkp.PrivilegeCount = 1;
		tkp.Privileges[0].Luid = sedebugnameValue;
		tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
		if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, sizeof(tkp), NULL, NULL))
		{
			return   FALSE;
		}
		CloseHandle(hToken);
		return TRUE;
	}
	*/
	int PIDManager::GetProcessThreadNumByID(DWORD dwPID)
	{
		//��ȡ������Ϣ
		HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		if (hProcessSnap == INVALID_HANDLE_VALUE)
			return 0;

		PROCESSENTRY32 pe32 = { 0 };
		pe32.dwSize = sizeof(pe32);
		BOOL bRet = ::Process32First(hProcessSnap, &pe32);;
		while (bRet)
		{
			if (pe32.th32ProcessID == dwPID)
			{
				::CloseHandle(hProcessSnap);
				return pe32.cntThreads;
			}
			bRet = ::Process32Next(hProcessSnap, &pe32);
		}
		return 0;
	}

	int PIDManager::GetAowProcId()
	{

		DWORD dwRet = 0;
		DWORD dwThreadCountMax = 0;
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		PROCESSENTRY32 pe32;
		pe32.dwSize = sizeof(PROCESSENTRY32);
		Process32First(hSnapshot, &pe32);
		do
		{
			//if (_tcsicmp(pe32.szExeFile, _T("GFXTest64.exe")) == 0)
			if (_tcsicmp(pe32.szExeFile, _T("League of Legends.exe")) == 0)
			{
				DWORD dwTmpThreadCount = GetProcessThreadNumByID(pe32.th32ProcessID);

				if (dwTmpThreadCount > dwThreadCountMax)
				{
					dwThreadCountMax = dwTmpThreadCount;
					dwRet = pe32.th32ProcessID;
				}
			}
		} while (Process32Next(hSnapshot, &pe32));
		CloseHandle(hSnapshot);
		return dwRet;

		//return GetCurrentProcessId();
	}

	/*
	void PIDManager::killProcessByName(LPCWSTR name)
	{
		HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL);
		PROCESSENTRY32 pEntry;
		pEntry.dwSize = sizeof(pEntry);
		BOOL hRes = Process32First(hSnapShot, &pEntry);
		while (hRes)
		{
			if (_wcsicmp(pEntry.szExeFile, name) == 0)
			{
				HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, 0,
					(DWORD)pEntry.th32ProcessID);
				if (hProcess != NULL)
				{
					TerminateProcess(hProcess, 9);
					CloseHandle(hProcess);
				}
			}
			hRes = Process32Next(hSnapShot, &pEntry);
		}
		CloseHandle(hSnapShot);
	}
	*/
}